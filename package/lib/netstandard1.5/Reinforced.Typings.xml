<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reinforced.Typings</name>
    </assembly>
    <members>
        <member name="T:Reinforced.Typings.AccessModifier">
            <summary>
                Represents member's access modifier
            </summary>
        </member>
        <member name="F:Reinforced.Typings.AccessModifier.Private">
            <summary>
                private
            </summary>
        </member>
        <member name="F:Reinforced.Typings.AccessModifier.Protected">
            <summary>
                protected
            </summary>
        </member>
        <member name="F:Reinforced.Typings.AccessModifier.Public">
            <summary>
                public
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.Dependency.RtImport">
            <summary>
            Import declaration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.Target">
            <summary>
            Targets list
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.IsWildcard">
            <summary>
            Gets flag whether RtImport is wildcard import
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.WildcardAlias">
            <summary>
            Gets wildcard alias of import
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.From">
            <summary>
            Import source
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.IsRequire">
            <summary>
            When true, "from" part will be replaced with "= require('From')"
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtImport.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtImport.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtImport.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.Dependency.RtReference">
            <summary>
            AST node for TS reference exposed as comment
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtReference.Path">
            <summary>
            File to reference
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtReference.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtReference.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtReference.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtReference.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.DocTag">
            <summary>
            Describes all possible JSDOC tags
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Abstract">
            <summary> This member must be implemented (or overridden) by the inheritor. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Access">
            <summary> Specify the access level of this member (private, public, or protected). </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Alias">
            <summary> Treat a member as if it had a different name. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Augments">
            <summary> Indicate that a symbol inherits from, ands adds to, a parent symbol. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Author">
            <summary> Identify the author of an item. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Borrows">
            <summary> This object uses something from another object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Callback">
            <summary> Document a callback function. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Class">
            <summary> This function is intended to be called with the "new" keyword. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Classdesc">
            <summary> Use the following text to describe the entire class. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Constant">
            <summary> Document an object as a constant. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Constructs">
            <summary> This function member will be the constructor for the previous class. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Copyright">
            <summary> Document some copyright information. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Default">
            <summary> Document the default value. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Deprecated">
            <summary> Document that this is no longer the preferred way. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Description">
            <summary> Describe a symbol. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Enum">
            <summary> Document a collection of related properties. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Event">
            <summary> Document an event. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Example">
            <summary> Provide an example of how to use a documented item. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Exports">
            <summary> Identify the member that is exported by a JavaScript module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.External">
            <summary> Identifies an external class, namespace, or module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.File">
            <summary> Describe a file. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Fires">
            <summary> Describe the events this method may fire. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Function">
            <summary> Describe a function or method. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Global">
            <summary> Document a global object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Ignore">
            <summary> Omit a symbol from the documentation. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Implements">
            <summary> This symbol implements an interface. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Inheritdoc">
            <summary> Indicate that a symbol should inherit its parent's documentation. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Inner">
            <summary> Document an inner object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Instance">
            <summary> Document an instance member. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Interface">
            <summary> This symbol is an interface that others can implement. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Kind">
            <summary> What kind of symbol is this? </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Lends">
            <summary> Document properties on an object literal as if they belonged to a symbol with a given name. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.License">
            <summary> Identify the license that applies to this code. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Listens">
            <summary> List the events that a symbol listens for. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Member">
            <summary> Document a member. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Memberof">
            <summary> This symbol belongs to a parent symbol. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Mixes">
            <summary> This object mixes in all the members from another object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Mixin">
            <summary> Document a mixin object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Module">
            <summary> Document a JavaScript module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Name">
            <summary> Document the name of an object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Namespace">
            <summary> Document a namespace object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Override">
            <summary> Indicate that a symbol overrides its parent. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Param">
            <summary> Document the parameter to a function. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Private">
            <summary> This symbol is meant to be private. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Property">
            <summary> Document a property of an object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Protected">
            <summary> This symbol is meant to be protected. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Public">
            <summary> This symbol is meant to be public. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Readonly">
            <summary> This symbol is meant to be read-only. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Requires">
            <summary> This file requires a JavaScript module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Returns">
            <summary> Document the return value of a function. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.See">
            <summary> Refer to some other documentation for more information. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Since">
            <summary> When was this feature added? </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Static">
            <summary> Document a static member. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Summary">
            <summary> A shorter version of the full description. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.This">
            <summary> What does the 'this' keyword refer to here? </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Throws">
            <summary> Describe what errors could be thrown. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Todo">
            <summary> Document tasks to be completed. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Tutorial">
            <summary> Insert a link to an included tutorial file. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Type">
            <summary> Document the type of an object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Typedef">
            <summary> Document a custom type. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Variation">
            <summary> Distinguish different objects with the same name. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Version">
            <summary>
            Documents the version number of an item
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.DocTagExtensions">
            <summary>
            Extension methods for DocTag enum
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.DocTagExtensions.Tagname(Reinforced.Typings.Ast.DocTag)">
            <summary>
            Converts DocTag value to corresponding JSDOC-friendly name
            </summary>
            <param name="tag">Tag instance</param>
            <returns>JSDOC-friendly name</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.IDecoratable">
            <summary>
            Node containing decorators
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.IDecoratable.Decorators">
            <summary>
            Set of decorators applied to node
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.IRtVisitor`1">
            <summary>
            Base interface for visitor traversing simple TypeScript AST tree
            </summary>
            <typeparam name="T">Node traverse result</typeparam>
        </member>
        <member name="T:Reinforced.Typings.Ast.IRtVisitor">
            <summary>
            Base interface for void visitor traversing simple TypeScript AST tree
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.ITypeMember">
            <summary>
            Abstraction for RtClass and RtInterface AST
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Export">
            <summary>
            Denotes current class to be exported
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.DefaultExport">
            <summary>
            Denotes that current class must be default export of module
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Members">
            <summary>
            Class/interface members
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Name">
            <summary>
            class/interface name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Implementees">
            <summary>
            Implementing types names
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Order">
            <summary>
            Order of writing
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.JsdocTagAttribute">
            <summary>
            JSDOC tag attribute to convert enum name back to JSDOC tag
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.JsdocTagAttribute.RawTagName">
            <summary>
            Raw tag name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.JsdocTagAttribute.#ctor(System.String)">
            <summary>
            Constructs new instance of JsdicTag attribute
            </summary>
            <param name="rawTagName">Raw tag name</param>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtArgument">
            <summary>
            AST node for method parameter
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.#ctor">
            <summary>
            Constructs new RtArgument
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Identifier">
            <summary>
            Parameter identifier
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.DefaultValue">
            <summary>
            Default value (raw typescript expression)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.IsVariableParameters">
            <summary>
            Is this parameter represents variable method parameterss
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Type">
            <summary>
            Argument type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.ToString">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Decorators">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtClass">
            <summary>
            AST node for TypeScript class
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Decorators">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Documentation">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Name">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Implementees">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Extendee">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Members">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtClass.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtClass.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtClass.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtCompilationUnit">
            <summary>
            Abstract AST node for class/interface/enum
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtCompilationUnit.Export">
            <summary>
            Denotes current class to be exported
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtCompilationUnit.DefaultExport">
            <summary>
            Denotes that current class must be default export of module
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtCompilationUnit.Order">
            <summary>
            Order of writing
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtConstructor">
            <summary>
            AST node for class constructor
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.Arguments">
            <summary>
            Constructor parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.SuperCallParameters">
            <summary>
            Array of arguments to be substitute to super(...) call
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.NeedsSuperCall">
            <summary>
            When true, super(...) call will be generated. Otherwise will not
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtConstructor.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.Body">
            <summary>
            Implementation body (raw content)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtConstructor.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtConstructor.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtDecorator">
            <summary>
            Syntax node for TS decorator
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtDecorator.Decorator">
            <summary>
            Decorator name (everything that must follow after "@")
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtDecorator.Order">
            <summary>
            Order of appearence
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtDecorator.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtDecorator.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtDecorator.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtDecorator.#ctor(System.String,System.Double)">
            <summary>
            Constructs new RtDecorator
            </summary>
            <param name="decorator">Decorator content</param>
            <param name="order">Decorator order</param>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtEnum">
            <summary>
            AST node for TypeScript enumeration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.EnumName">
            <summary>
            Enum name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Values">
            <summary>
            Enum values
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnum.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.IsConst">
            <summary>
            When true, results "const" enum instead of usual
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnum.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnum.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Decorators">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtEnumValue">
            <summary>
            AST node for TypeScript enumeration value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.EnumValueName">
            <summary>
            Value name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.EnumValue">
            <summary>
            Value value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnumValue.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnumValue.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtField">
            <summary>
            AST node for TypeScript field
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Identifier">
            <summary>
            Field name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Type">
            <summary>
            Field type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.InitializationExpression">
            <summary>
            TypeScript expression to initialize field
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtField.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtField.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtField.#ctor">
            <summary>
            Constructs new RtField
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Decorators">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtFuncion">
            <summary>
            AST node for TypeScript member function
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtFuncion.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFuncion.Identifier">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFuncion.ReturnType">
            <summary>
            Function return type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFuncion.Arguments">
            <summary>
            Function parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFuncion.Decorators">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFuncion.Body">
            <summary>
            Function body (supplied as raw text)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFuncion.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtFuncion.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtFuncion.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtIdentifier">
            <summary>
            AST node for identifier name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.#ctor(System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="identifierName">identifier name</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtIdentifier.IdentifierName">
            <summary>
            Identifier name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtIdentifier.IsNullable">
            <summary>
            Is current identifier nullable
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtIdentifier.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtInterface">
            <summary>
            AST node for typeScript interface
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Name">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Implementees">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Documentation">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Members">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtInterface.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtInterface.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtInterface.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtJsdocNode">
            <summary>
            AST node for JSDOC documentation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtJsdocNode.Description">
            <summary>
            Main documentation text
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtJsdocNode.TagToDescription">
            <summary>
            Additional JSDOC documentation tags
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtJsdocNode.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtMember">
            <summary>
            Abstract AST node for class/interface member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.AccessModifier">
            <summary>
            Access modifier
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.IsStatic">
            <summary>
            Is member static
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.Order">
            <summary>
            Member order
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtNamespace">
            <summary>
            AST node for TypeScript module
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNamespace.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.IsAmbientNamespace">
            <summary>
            Identifies nameless namespace that only wraps CompilationUnits without module name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.Name">
            <summary>
            Module name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.Export">
            <summary>
            Denotes whether namespace must be exported or not
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.GenerationMode">
            <summary>
            Denotes namespace generation mode
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.CompilationUnits">
            <summary>
            Members of module - compilation units. Classes/enums/interfaces
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNamespace.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNamespace.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.NamespaceGenerationMode">
            <summary>
            Switches mode for generating namespace.
            If UseModules set to true then namespace must be 
            exported as Namespaces.
            If modules are not used then namespaces must represent modules
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Ast.NamespaceGenerationMode.Module">
            <summary>
            Export namespace as module
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Ast.NamespaceGenerationMode.Namespace">
            <summary>
            Export namespace as namespace
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtNode">
            <summary>
            Base Reinforced.Typings AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNode.Children">
            <summary>
            Child nodes
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNode.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <summary>
            Visitor acceptance
            </summary>
            <param name="visitor">Visitor</param>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNode.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <summary>
            Typed visitor acceptance
            </summary>
            <param name="visitor">Visitor</param>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtRaw">
            <summary>
            AST node exposing raw text to be output to resulting file
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.#ctor(System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="rawContent">Raw text to be output to resulting file</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtRaw.RawContent">
            <summary>
            Raw text to be output to resulting file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtRaw.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtArrayType">
            <summary>
            AST node for array type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtArrayType.ElementType">
            <summary>
            Array element type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs array type from existing type
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtArrayType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtDelegateType">
            <summary>
            AST node for delegate type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Arguments">
            <summary>
            Consumed arguments
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Result">
            <summary>
            Returning result
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.#ctor(Reinforced.Typings.Ast.RtArgument[],Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="arguments">Delegate parameters</param>
            <param name="result">Delegate result type</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtDictionaryType">
            <summary>
            AST node for Dictionary type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.#ctor(System.String,System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="keySimpleType">Type for dictionary key</param>
            <param name="valueSimpleType">Type for disctionary value</param>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName,Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="keySimpleType">Type for dictionary key</param>
            <param name="valueSimpleType">Type for disctionary value</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.KeyType">
            <summary>
            Type for dictionary key
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.ValueType">
            <summary>
            Type for disctionary value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName">
            <summary>
            AST node for simple type name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName[],System.String,System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor(System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor(System.String,Reinforced.Typings.Ast.TypeNames.RtTypeName[])">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.GenericArguments">
            <summary>
            Type name generic arguments
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Prefix">
            <summary>
            Type namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.TypeName">
            <summary>
            Type name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtTuple">
            <summary>
            AST node for TypeScript tuple type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.#ctor">
            <summary>
            Constructs new RtTuple
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.#ctor(System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Constructs new RtTuple with specified type paranmeters
            </summary>
            <param name="tupleTypes">Types for tuple</param>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName[])">
            <summary>
            Constructs new RtTuple with specified type paranmeters
            </summary>
            <param name="tupleTypes">Types for tuple</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtTuple.TupleTypes">
            <summary>
            All types that must participate tuple
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtTuple.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtTypeName">
            <summary>
            Abstract AST node for type name
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute">
            <summary>
                Interface containing base properties for some attributes
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportMethods">
            <summary>
                When true, code for all methods will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportProperties">
            <summary>
                When true, code for all properties will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportFields">
            <summary>
                When true, code for all fields will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.DefaultMethodCodeGenerator">
            <summary>
                Reference to code geenrator which will be applied to every method
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportConstructors">
            <summary>
                When true, code for all constructors will be automatically generated
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.INameOverrideAttribute">
            <summary>
                Configuration interface for members supporting names overriding
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.INameOverrideAttribute.Name">
            <summary>
                Name override
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.ICamelCaseableAttribute">
            <summary>
                Configuration interface for members supporting camelCasing from attribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.ICamelCaseableAttribute.ShouldBeCamelCased">
            <summary>
                camelCase flag
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.IPascalCasableAttribute">
            <summary>
                Configuration interface for members supporting PascalCasing from attribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IPascalCasableAttribute.ShouldBePascalCased">
            <summary>
                PascalCase flag
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.IOrderableAttribute">
            <summary>
            Configuration interface for attribute for supporting reordering from attribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IOrderableAttribute.Order">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsAddTypeImportAttribute">
            <summary>
                This attribute is used to add import directive to file containing single TS class typing.
                It is only used while splitting generated type sto different files
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.ImportTarget">
            <summary>
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.ImportSource">
            <summary>
            Import source is everything that follows after "from" keyword. 
            Please note that you do not have to specify quotes here! Quotes will be added automatically
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.ImportRequire">
            <summary>
            When true, import will be generated as "import ImportTarget = require('ImportSource')"
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Cosntructs new Rtimport
            </summary>
            <param name="importTarget">Target</param>
            <param name="importSource">Source</param>
            <param name="importRequire">Is import "=require(...)"</param>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute">
            <summary>
                This attribute is used to add reference directive to file containing single TS class typing.
                It is only used while splitting generated type sto different files
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.#ctor(System.Type)">
            <summary>
                Constructs new instance of TsAddTypeReferenceAttribute using referenced type
            </summary>
            <param name="type">Type reference</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsAddTypeReferenceAttribute using referenced type
            </summary>
            <param name="rawPath">Raw reference</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.Type">
            <summary>
                Type that should be referenced
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.RawPath">
            <summary>
                Raw reference path that will be added to target file
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsAttributeBase">
            <summary>
                Base for all attributes
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAttributeBase.CodeGeneratorType">
            <summary>
                Dummy function body generator
                If empty then it's being generated empty/return null body.
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsBaseParamAttribute">
            <summary>
                Denotes parameter name and constant value for constructor's :base call
                We need this attribute because it is programmatically impossible to determine :base call parameters
                via reflection. So in this case we need some help from user's side
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="value">TypeScript expression to be supplied for super() call</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
            <param name="sixthValue">TypeScript expression to be supplied for super() call at position 6</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
            <param name="sixthValue">TypeScript expression to be supplied for super() call at position 6</param>
            <param name="seventhValue">TypeScript expression to be supplied for super() call at position 7</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
            <param name="sixthValue">TypeScript expression to be supplied for super() call at position 6</param>
            <param name="seventhValue">TypeScript expression to be supplied for super() call at position 7</param>
            <param name="eighthValue">TypeScript expression to be supplied for super() call at position 8</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsBaseParamAttribute.Values">
            <summary>
                Parameters for super() call
                Here should be stored TypeScript expressions
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsClassAttribute">
            <summary>
                This attribute will export member as typescript class definition
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsClassAttribute.#ctor">
            <summary>
                Constructs new instance of TsClassAttribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportMethods">
            <summary>
                Export all methods automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportProperties">
            <summary>
                Export all properties automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportFields">
            <summary>
                Export all fields automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.DefaultMethodCodeGenerator">
            <summary>
                Reference to code geenrator which will be applied to every method
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportConstructors">
            <summary>
                When true, code for all constructors will be automatically generated
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsDeclarationAttributeBase">
            <summary>
                Base attribute for so-called compilation unit (class, enum, interface etc)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.#ctor">
            <summary>
                Constructs new instance of TsDeclarationAttributeBase
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.IncludeNamespace">
            <summary>
                Place to corresponding namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.Namespace">
            <summary>
                Overrides namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.Name">
            <summary>
                Overrides name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.Order">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsDecoratorAttribute">
            <summary>
            Adds decorator to class/method/parameter/property
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDecoratorAttribute.Decorator">
            <summary>
            Decorator text - everything that must follow after @
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDecoratorAttribute.Order">
            <summary>
            Decorator order
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsDecoratorAttribute.#ctor(System.String,System.Double)">
            <summary>
            Creates decorator attribute
            </summary>
            <param name="decorator">Decorator text - everything that follows after @</param>
            <param name="order">Decorator order of appearence</param>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsEnumAttribute">
            <summary>
                Exports enum as TypeScript Enum
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsEnumAttribute.IsConst">
            <summary>
            When true, results "const" enum instead of usual
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsFileAttribute">
            <summary>
                Specifies file where to put generated code for type.
                This attribute is being ignored when RtDivideTypesAmongFiles is false.
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsFileAttribute.#ctor(System.String)">
            <summary>
                Constructs new TsFile attribute
            </summary>
            <param name="fileName">File name (related to RtTargetDirectory) where to put generated code</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFileAttribute.FileName">
            <summary>
                File name (related to RtTargetDirectory) where to put generated code
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsFunctionAttribute">
            <summary>
                Overrides function export
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.Order">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.Implementation">
            <summary>
            Inline function code to be converted to RtRaw and used as function body
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsGenericAttribute">
            <summary>
                Denotes type for generic attribute
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsGenericAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsGenericAttribute
            </summary>
            <param name="type">Raw TypeScript type name</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsGenericAttribute.#ctor(System.Type)">
            <summary>
                Constructs new instance of TsGenericAttribute
            </summary>
            <param name="strongType">Type to be resolved to TypeScript name during export</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGenericAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsGlobalAttribute">
            <summary>
            Sets global parameters for RT export.
            Warning! Use Priority property to control [TsGlobal] processing order. 
            When exporting multiple assemblies and several ones will contain [TsGlobal] then the one with 
            highest priority will be used. Global parameters configured from fluent configuration 
            using builder.Global method always has highest priority
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.WriteWarningComment">
            <summary>
                Boolean parameter that controls writing of "auto-generated warning" comment to each generated file.
            It meant the comment like "// This code was generated blah blah blah..."
            'true' (default) to write warning comment about auto-generated to every file.
            'false' to do not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.RootNamespace">
            <summary>
                Specifies root namespace for hierarchical export.
                Helps to avoid creating redundant directories when hierarchical export.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.CamelCaseForMethods">
            <summary>
                Use camelCase for methods naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.CamelCaseForProperties">
            <summary>
                Use camelCase for properties naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.GenerateDocumentation">
            <summary>
                Enables or disables documentation generator
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.TabSymbol">
            <summary>
            Specifies symbol used for tabulation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.UseModules">
            <summary>
            Switches RT to using TS modules system (--module tsc.exe parameter) and import references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.DiscardNamespacesWhenUsingModules">
            <summary>
            When true, RT will ignore classes' namespaces when arraging classes and interfaces among files. 
            This parameter only makes difference when using (--module)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.ExportPureTypings">
            <summary>
                If true, export will be performed in .d.ts manner (only typings, declare module etc).
                Otherwise, export will be performed to regulat .ts file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.Priority">
            <summary>
            Sets order of applying paramters from this attribute
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsGlobalAttribute.#ctor">
            <summary>
            Default constructor for TsGlobal attribute
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsIgnoreAttribute">
            <summary>
                Instructs DynTyping do not to export mentioned member
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsImportAttribute">
            <summary>
                Specifies path of reference which required to be added to result .ts file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsImportAttribute.ImportTarget">
            <summary>
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsImportAttribute.ImportSource">
            <summary>
            Import source is everything that follows after "from" keyword. 
            Please not the you do not have to specify quotes here! Quotes will be added automatically
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsImportAttribute.ImportRequire">
            <summary>
            When true, import will be generated as "import ImportTarget = require('ImportSource')"
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsInterfaceAttribute">
            <summary>
                Exports specified class or interface as typescript interface
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsInterfaceAttribute.#ctor">
            <summary>
                Constructs new instance of TsInterfaceAttribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsInterfaceAttribute.AutoI">
            <summary>
                Automatically appends I prefix if non-interfaces
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsInterfaceAttribute.AutoExportMethods">
            <summary>
                Export all methods automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsInterfaceAttribute.AutoExportProperties">
            <summary>
                Export all properties automatically or not.
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsParameterAttribute">
            <summary>
                Overrides settings for exporting parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsParameterAttribute.DefaultValue">
            <summary>
                Specifies default value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsParameterAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsPropertyAttribute">
            <summary>
                Overrides property/field export settings
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.NilForceNullable">
            <summary>
                Forces property to be a nullable
                E.g. `field:boolean` becomes `field?:boolean` when you specify `[TsProperty(ForceNullable = true)]` in attribute configuration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.ForceNullable">
            <summary>
                Forces property to be a nullable
                E.g. `field:boolean` becomes `field?:boolean` when you specify `[TsProperty(ForceNullable = true)]` in attribute configuration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.Order">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsReferenceAttribute">
            <summary>
                Specifies path of reference which required to be added to result .ts file
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsReferenceAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsReferenceAttribute
            </summary>
            <param name="path">Path that should be written as file to reference tag</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsReferenceAttribute.Path">
            <summary>
                Path to referenced TS file
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsTypedAttributeBase">
            <summary>
                Base attribute for typed members/parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedAttributeBase.Type">
            <summary>
                Overrides member type name in resulting TypeScript. 
                Supplied as string. Helpful when property type is not present in your project. 
                E.g. - JQquery object.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedAttributeBase.StrongType">
            <summary>
                Similar to `Type`, but you can specify .NET type using typeof. 
                It is useful e.g. for delegates
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase">
            <summary>
                Base attribute for class members and method parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase.ShouldBeCamelCased">
            <summary>
                When true them member name will be camelCased regardless configuration setting
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase.ShouldBePascalCased">
            <summary>
                When true them member name will be PascalCased regardless configuration setting
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase.Name">
            <summary>
                Overrides member name
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsValueAttribute">
            <summary>
                Specifies exporting enum value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsValueAttribute.Name">
            <summary>
                Overrides enum value name
            </summary>
        </member>
        <member name="T:Reinforced.Typings.ConfiguredTypesExtensions">
            <summary>
            Set of extension methods for RT configured types
            </summary>
        </member>
        <member name="F:Reinforced.Typings.ConfiguredTypesExtensions.TypeScriptMemberSearchPredicate">
            <summary>
                Search predicate to exclude ignored and compiler-generated items
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetExportedProperties(System.Type)">
            <summary>
                Returns all properties that should be exported to TypeScript for specified type
            </summary>
            <param name="t">Type</param>
            <returns>Properties array</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetExportedFields(System.Type)">
            <summary>
                Returns all fields that should be exported to TypeScript for specified type
            </summary>
            <param name="t">Type</param>
            <returns>Fields array</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetExportedMethods(System.Type)">
            <summary>
                Returns all methods that should be exported to TypeScript for specified type
            </summary>
            <param name="t">Type</param>
            <returns>Methods array</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetOrder(System.Reflection.MemberInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetOrder(System.Reflection.MethodInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetOrder(System.Reflection.PropertyInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetOrder(System.Reflection.FieldInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetOrder(System.Type)">
            <summary>
                Retrieves type order to appear in results file
            </summary>
            <param name="t">Type</param>
            <returns>Type name</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetName(System.Reflection.ParameterInfo)">
            <summary>
                Retrieves parameter name from corresponding attribute. If attribute not present then takes parameter name via
                reflection
            </summary>
            <param name="element">Parameter info</param>
            <returns>Parameter name</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetName(System.Type,Reinforced.Typings.Ast.TypeNames.RtTypeName[])">
            <summary>
                Retrieves type name from type itself or from corresponding Reinforced.Typings attribute
            </summary>
            <param name="t">Type</param>
            <param name="genericArguments">Generic arguments to be substituted to type</param>
            <returns>Type name</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.IsExportingAsInterface(System.Type)">
            <summary>
                Determines should type be exported as interface or not
            </summary>
            <param name="t">Type</param>
            <returns>True, if supplied type should be exported as interface. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.IsExportingAsClass(System.Type)">
            <summary>
                Determines should type be exported as class or not
            </summary>
            <param name="t">Type</param>
            <returns>True, if supplied type should be exported as interface. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.IsIgnored(System.Reflection.MemberInfo)">
            <summary>
                Determines if type member should be ignored for translation using corresponding Typings attribute
            </summary>
            <param name="t">Type member info</param>
            <returns>True if type member should be ignored, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.IsIgnored(System.Reflection.ParameterInfo)">
            <summary>
                Determines if parameter should be ignored for translation using corresponding Typings attribute
            </summary>
            <param name="t">Parameter info</param>
            <returns>True if parameter should be ignored, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.GetNamespace(System.Type,System.Boolean)">
            <summary>
                Retrieves type namespace from type itself or from corresponding Typings attribute
            </summary>
            <param name="t">Type</param>
            <param name="distinguishAutoTypes">
                Forces GetNamespace to return "-" for interfaces with IncludeInterface = false and
                null for anonymous types
            </param>
            <returns>Full-qualified namespace name</returns>
        </member>
        <member name="M:Reinforced.Typings.ConfiguredTypesExtensions.Substitute(System.Type,System.Type)">
            <summary>
            Obtains substitution for type
            </summary>
            <param name="t">Type to find substitution for</param>
            <param name="currentlyExportingType">Currently exported type (to look up substitutions)</param>
            <returns>Substitution AST</returns>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.ErrorMessages">
            <summary>
            This class contains all RT's error and siagnostic messages. 
            Why didnt I use resources? I dont want to add one more .dll to RT's NuGet package. 
            if localization will be required through issues then I will add one
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0001_TempFileError">
            <summary>
            Could not acuire temorary file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0002_DeployingFilesError">
            <summary>
            Could not replace source file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0003_GeneratorInstantiate">
            <summary>
            Could not instantiate code generator {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0004_GeneratorError">
            <summary>
            Code generator {0} has thrown an error: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0005_TypeResolvationError">
            <summary>
            Could not resolve type for {0}. An error occured: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0006_FluentSingleError">
            <summary>
            Exception thrown when applying fluent configuration method for {1} '{2}': {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0007_FluentBatchError">
            <summary>
            Exception thrown when applying fluent configuration method for collection of {1}: {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0008_FluentWithMethodError">
            <summary>
            MethodCallExpression should be provided for .WithMethod call. Please use only lamba expressions in this place.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0009_FluentWithMethodCouldNotParse">
            <summary>
            Sorry, but {0} is not very good idea for parameter configuration. Try using simplier lambda expression.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0010_PropertyLambdaExpected">
            <summary>
            Property lambda expression expected in {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0011_FieldLambdaExpected">
            <summary>
            Field lambda expression expected in {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0012_NewExpressionLambdaExpected">
            <summary>
            NewExpression should be provided for .WithConstructor call. Please use only lamba expressions in this place.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0001_DocumentationNotSupplied">
            <summary>
            XMLDOC file not supplied
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0002_DocumentationNotFound">
            <summary>
            Could not find XMLDOC file {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0003_TypeUnknown">
            <summary>
            Could not find suitable TypeScript type for {0}. 'any' assumed.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0004_DefaultSuperCall">
            <summary>
            No suitable base constructor found for {0}. Generating 'super' call with all nulls.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0005_BaseClassExportingAsInterface">
            <summary>
            Class {0} (base for {1}) is exported as interface. It is potentially unsafe facility.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0006_DocumentationParseringError">
            <summary>
            Error parsering XMLDOC file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0007_InvalidDictionaryKey">
            <summary>
            Error parsering XMLDOC file {0}: {1}
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.RtException">
            <summary>
            Base class for RT exception. 
            All the RT exceptions will be provided to VisualStudio's errors tab
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtException.Code">
            <summary>
            Internal error code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtException.Subcategory">
            <summary>
            Error subcategory
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Exceptions.RtException.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs new RT exception
            </summary>
            <param name="message">Error message</param>
            <param name="code">Error code</param>
            <param name="subcategory">Error subcategory (optional)</param>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.RtWarning">
            <summary>
            Represents warning message that could be displayed during build. 
            Warnings can be added to global warnings collection located at ExportContext.Warnings. 
            ExportContext instance can be found inside every TsCodeGeneratorBase
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtWarning.Code">
            <summary>
            Warning code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtWarning.Subcategory">
            <summary>
            Warning subcategory
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtWarning.Text">
            <summary>
            Warning detailed text
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Exceptions.RtWarning.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Instantiates new RtWarning that is suitable be added to warnings collection.  
            </summary>
            <param name="code">Warning code</param>
            <param name="subcategory">Warning subcategory (optional). Important! Warning subcategory should not contain word "warning" and ":" symbol</param>
            <param name="text">Warning text</param>
        </member>
        <member name="T:Reinforced.Typings.ExportContext">
            <summary>
                TsExport exporting settings
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.FileOperations">
            <summary>
            File I/O operations frontend
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ExportContext.#ctor(Reinforced.Typings.IFilesOperations)">
            <summary>
            Instantiates new ExportContext instance (only for testing/integration)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Location">
            <summary>
            Identifies where current export is performed in terms of AST. 
            Context.Location could be used to conditionally add members to different places of generated source code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.SourceAssemblies">
            <summary>
                The assemblies to extract typings from.
                Important! TsExporter do not perform any job for loading assemblies. It is left upon a calling side.
                That is because loading assemblies is highly dependent on calling side's AppDomain.
                TsExporter shouldnt handle all this shit
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Hierarchical">
            <summary>
                True to create project hierarchy in target folder.
                False to store generated typings in single file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.TargetDirectory">
            <summary>
                Target directory where to store generated typing files.
                This parameter is not used when Hierarcy is false
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.TargetFile">
            <summary>
                Target file where to store generated sources.
                This parameter is not used when Hierarchy is true
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.DocumentationFilePath">
            <summary>
                Path to assembly's XMLDOC file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.ConfigurationMethod">
            <summary>
                Fluent configuration method
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Documentation">
            <summary>
                Documentation manager
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Warnings">
            <summary>
            Warnings that should be displayed after build. 
            Feel free to add messages from generators here.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.SpecialCase">
            <summary>
                There is a case when you are exporting base class as interface. It may lead to some unusual handling of generation,
                so I'm using this property to denote such cases and fix it in-place
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Global">
            <summary>
            Global generation parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Generators">
            <summary>
            Generators cache
            </summary>
        </member>
        <member name="T:Reinforced.Typings.ExportedFile">
            <summary>
            Resulting TS file model
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.References">
            <summary>
            File references and imports
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.Namespaces">
            <summary>
            Namespaces ASTs
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.TypeResolver">
            <summary>
            Type Resolver object
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.AllTypesIsSingleFile">
            <summary>
            Gets or sets whether all exported types are stored in single file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.TypesToExport">
            <summary>
            Set of types being exported within this file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.FileName">
            <summary>
            Absolute file path+name+extension
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ClassConfigurationBuilder`1">
            <summary>
                Export configuration builder for class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ClassConfigurationBuilder`1.MemberOrder">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Fluent.ConfigurationBuilder">
            <summary>
                Fluent configuration builder
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions">
            <summary>
                Extensions for configuration builders
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.Decorator``1(``0,System.String,System.Double)">
            <summary>
            Adds decorator to member
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conf">Member configurator</param>
            <param name="decorator">Decorator to add (everything that must follow after "@")</param>
            <param name="order">Order of appearence</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithProperty``2(Reinforced.Typings.Fluent.TypeConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="property">Property to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithProperty``2(Reinforced.Typings.Fluent.InterfaceConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="property">Property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithProperty``2(Reinforced.Typings.Fluent.ClassConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="property">Property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithProperties``1(``0,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="properties">Properties to include</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithProperties``1(``0,System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="predicate">Predicate function for properties to include</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithProperties``1(``0,System.Reflection.BindingFlags,System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="bindingFlags">BindingFlags describing properties to include</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithAllProperties``1(``0,System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include all properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithPublicProperties``1(``0,System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include all public properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithField``2(Reinforced.Typings.Fluent.TypeConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Include specified field to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="field">Field to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithField``2(Reinforced.Typings.Fluent.InterfaceConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="property">Property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithField``2(Reinforced.Typings.Fluent.ClassConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="property">Property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithFields``1(``0,System.Collections.Generic.IEnumerable{System.Reflection.FieldInfo},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="fields">Fields to include</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithFields``1(``0,System.Func{System.Reflection.FieldInfo,System.Boolean},System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="predicate">Predicate function that should mathc for fields to include</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithAllFields``1(``0,System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include all fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithPublicFields``1(``0,System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include all public fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithFields``1(``0,System.Reflection.BindingFlags,System.Action{Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder})">
            <summary>
                Include specified fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="bindingFlags">BindingFlags describing fields to include</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethod``2(Reinforced.Typings.Fluent.TypeConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethod``2(Reinforced.Typings.Fluent.InterfaceConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <param name="configuration">configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethod``2(Reinforced.Typings.Fluent.ClassConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <param name="configuration">Configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethod``1(Reinforced.Typings.Fluent.TypeConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethod``1(Reinforced.Typings.Fluent.InterfaceConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Action{``0}},System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <param name="configuration">Configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethod``1(Reinforced.Typings.Fluent.ClassConfigurationBuilder{``0},System.Linq.Expressions.Expression{System.Action{``0}},System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <param name="configuration">Configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethods``1(``0,System.Func{System.Reflection.MethodInfo,System.Boolean},System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified methods to resulting typing.
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="predicate">Predicate function that should mathc for methods to include</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethods``1(``0,System.Reflection.BindingFlags,System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified methods to resulting typing.
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="bindingFlags">BindingFlags describing methods to include</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithMethods``1(``0,System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include specified methods to resulting typing.
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="methods">Methods to include</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithAllMethods``1(``0,System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include all methods to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.WithPublicMethods``1(``0,System.Action{Reinforced.Typings.Fluent.MethodConfigurationBuilder})">
            <summary>
                Include all methods to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.ExportAsInterface``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Includes specified type to resulting typing exported as interface
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.ExportAsInterfaces(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.Interfaces.IInterfaceConfigurationBuilder})">
            <summary>
                Includes specified types to resulting typing exported as interfaces
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.ExportAsClass``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Includes specified type to resulting typing exported as TypeScript class
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.ExportAsClasses(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.Interfaces.IClassConfigurationBuilder})">
            <summary>
                Includes specified types to resulting typing exported as TypeScript classes
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.ExportAsEnum``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Includes specified type to resulting typing exported as TypeScript enumeration
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.ExportAsEnums(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.Interfaces.IEnumConfigurationBuidler})">
            <summary>
                Includes specified types to resulting typing exported as TypeScript enumerations
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.Const``1(``0,System.Boolean)">
            <summary>
            Turns enum to constant enum
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conf">Enum configurator</param>
            <param name="isConst">When true, "const enum" will be generated. Regular enum otherwise</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.Value``1(Reinforced.Typings.Fluent.EnumConfigurationBuilder{``0},``0)">
            <summary>
                Retrieves configuration builder for particular enumeration value
            </summary>
            <typeparam name="T">Enumeration type</typeparam>
            <param name="conf">Configuration builder</param>
            <param name="value">Enum value</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuildersExtensions.Value(Reinforced.Typings.Fluent.Interfaces.IEnumConfigurationBuidler,System.String)">
            <summary>
                Retrieves configuration builder for particular enumeration value
            </summary>
            <param name="conf">Configuration builder</param>
            <param name="propertyName">String enum property name</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.EnumConfigurationBuilder`1">
            <summary>
                Configuration builder for Enum type
            </summary>
            <typeparam name="TEnum"></typeparam>
        </member>
        <member name="T:Reinforced.Typings.Fluent.EnumValueExportConfiguration">
            <summary>
                Configuration for enum value export configuration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.EnumValueExportConfiguration.Member">
            <summary>
            Exporting member
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.GlobalConfigurationBuilder">
            <summary>
            Global configuration builder
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.GlobalConfigurationExtensions">
            <summary>
            Set of extensions for global configuration
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.Global(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Action{Reinforced.Typings.Fluent.GlobalConfigurationBuilder})">
            <summary>
            Configures global exporting parameters
            </summary>
            <param name="builder">Conf builder</param>
            <param name="config">Global configuration action</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.DontWriteWarningComment(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Disables writing of "auto-generated warning" comment to each generated file.
            It meant the comment like "// This code was generated blah blah blah..."
            </summary>
            <param name="builder">Conf builder</param>
            <param name="dontWrite">Pass 'true' (default) to disable adding warning comment to target file. Pass 'false' to leave this label in place.</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.TabSymbol(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.String)">
            <summary>
            Changes indentation symbol (by default is \t). 
            This ability is made by @jonsa's request - boring perfectionist
            </summary>
            <param name="builder">Conf builder</param>
            <param name="symbol">New indentation symbol</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.RootNamespace(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.String)">
            <summary>
                Specifies root namespace for hierarchical export.
                Helps to avoid creating redundant directories when hierarchical export.
            </summary>
            <param name="builder">Conf builder</param>
            <param name="rootNamespace">Application root namespace</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.CamelCaseForMethods(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Use camelCase for methods naming
            </summary>
            <param name="builder">Conf builder</param>
            <param name="cameCase">Pass 'true' to convert all MethodsNames to camelCase </param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.CamelCaseForProperties(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Use camelCase for properties naming
            </summary>
            <param name="builder">Conf builder</param>
            <param name="cameCase">Pass 'true' to convert all MethodsNames to camelCase </param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.GenerateDocumentation(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Enables documentation generator
            </summary>
            <param name="builder">Conf builder</param>
            <param name="generate">Pass 'true' to generate JSDOC for exported types from XMLDOC</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.UseModules(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean,System.Boolean)">
            <summary>
            Enables adaptation for TS modules system (--modules tsc.exe option)
            </summary>
            <param name="builder">Conf builder</param>
            <param name="useModules">True will enable usage of modules system and exports/imports</param>
            <param name="discardNamespaces">True will automatically ignore namespaces while exporting types</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.ExportPureTypings(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
             If true, export will be performed in .d.ts manner (only typings, declare module etc).
             Otherwise, export will be performed to regulat .ts file
            </summary>
            <param name="builder">Conf builder</param>
            <param name="typings">Enables or disables option</param>
        </member>
        <member name="T:Reinforced.Typings.Fluent.InterfaceConfigurationBuilder`1">
            <summary>
                Configuration builder for interface
            </summary>
            <typeparam name="TInterface"></typeparam>
        </member>
        <member name="P:Reinforced.Typings.Fluent.InterfaceConfigurationBuilder`1.MemberOrder">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IAttributed`1">
            <summary>
                Core fluent export configuration interface
            </summary>
            <typeparam name="TAttributePrototype">Attribute prototype for specified member</typeparam>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IAttributed`1.AttributePrototype">
            <summary>
                Attribute prototype
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IMemberExportConfiguration`2">
            <summary>
            Member export configuration
            </summary>
            <typeparam name="TAttributePrototype"></typeparam>
            <typeparam name="TMember"></typeparam>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IMemberExportConfiguration`2.Member">
            <summary>
            Exporting member
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IClassConfigurationBuilder">
            <summary>
                Technical interface for class configuration builder
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IDecoratorsAggregator">
            <summary>
            Configuration interface for members supporting decorators aggregation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IDecoratorsAggregator.Decorators">
            <summary>
            Aggregated decorators
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IEnumConfigurationBuidler">
            <summary>
                Technical interface for enumeration configuration builder
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IEnumConfigurationBuidler.EnumType">
            <summary>
                Type of enumeration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IEnumConfigurationBuidler.ValueExportConfigurations">
            <summary>
                Configurations for exported particular enumeration values
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IIgnorable">
            <summary>
                Configuration for members that are supporting ignoring
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IIgnorable.Ignore">
            <summary>
                Ignore flag
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IInterfaceConfigurationBuilder">
            <summary>
                Technical interface for interface configuration builder
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IOrderableMember">
            <summary>
            Configuration interface for members supporting reordering from attribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IOrderableMember.MemberOrder">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.IReferenceConfigurationBuilder">
            <summary>
                Configuration interface for members supporting custom typescript-per-file references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IReferenceConfigurationBuilder.References">
            <summary>
                Reference paths list
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IReferenceConfigurationBuilder.Imports">
            <summary>
                Imports list
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.IReferenceConfigurationBuilder.PathToFile">
            <summary>
                Path to file where to put generated code
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Interfaces.ITypeConfigurationBuilder">
            <summary>
                Technical interface for type (class/interface) configuration builder
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.ITypeConfigurationBuilder.ParametersConfiguration">
            <summary>
                Configurations for method parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.ITypeConfigurationBuilder.MembersConfiguration">
            <summary>
                Configurations for type members
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.ITypeConfigurationBuilder.Type">
            <summary>
                Type is being configured
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.Interfaces.ITypeConfigurationBuilder.Substitutions">
            <summary>
            Substitutions to be used only when in this type
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.LambdaHelpers">
            <summary>
                Set of helper reflection methods
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParsePropertyLambda``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <typeparam name="T1">T1</typeparam>
            <typeparam name="T2">T2</typeparam>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParsePropertyLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseFieldLambda``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <typeparam name="T1">T1</typeparam>
            <typeparam name="T2">T2</typeparam>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseFieldLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseMethodLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves MethodInfo from it
            </summary>
            <param name="lambda">Method lambda expression</param>
            <returns>MethodInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseConstructorLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves ConstructorInfo from it
            </summary>
            <param name="lambda">Constructor lambda expression ( => new Obejct(Ts.Parameter...))</param>
            <returns>Constructor referenced by this expression</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.MethodConfigurationBuilder">
            <summary>
                Fluent configuration builder for exported methods
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.MethodConfigurationBuilder.Member">
            <summary>
            Exporting member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.MethodConfigurationBuilder.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Ts">
            <summary>
                Shortcut for method parameters mocking
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.Ts.Parameter``1">
            <summary>
                Parameter mock for specified type
            </summary>
            <typeparam name="T">Parameter type</typeparam>
            <returns>Mock</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.Ts.Parameter``1(System.Action{Reinforced.Typings.Fluent.ParameterConfigurationBuilder})">
            <summary>
                Parameter mock with parameter configuration
            </summary>
            <typeparam name="T">Parameter type</typeparam>
            <param name="configuration">Fluent parameter configuration</param>
            <returns>Mock</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ParameterConfigurationBuilder">
            <summary>
                Parameter configuration builder
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ParameterConfigurationBuilder.Member">
            <summary>
            Exporting member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ParameterConfigurationBuilder.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder">
            <summary>
                Fluent configuration builder for exported properties
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder.Member">
            <summary>
            Exporting member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.PropertyExportConfigurationBuilder.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.TypeConfigurationBuilder`1">
            <summary>
                Configuration builder for type
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="P:Reinforced.Typings.Fluent.TypeConfigurationBuilder`1.MemberOrder">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Fluent.TypingsConfigurationExtensions">
            <summary>
                Extensions for fluent configuration
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Ignore``1(``0)">
            <summary>
                Ignores specified mambers during exporting
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsClassAttribute})">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsInterfaceAttribute})">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsEnumAttribute})">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsPropertyAttribute})">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsFunctionAttribute})">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsParameterAttribute})">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.AddReference``1(``0,System.String)">
            <summary>
                Adds reference directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="configuration">Configurator</param>
            <param name="referenceFile">Path to referenced file</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.AddReference``1(``0,System.Type)">
            <summary>
                Adds reference directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="configuration">Configurator</param>
            <param name="referencedType">Another generated type that should be referenced</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.AddImport``1(``0,System.String,System.String,System.Boolean)">
            <summary>
                Adds import directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="configuration">Configurator</param>
            <param name="target">
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </param>
            <param name="from">
            Import source is everything that follows after "from" keyword. 
            Please not the you do not have to specify quotes here! Quotes will be added automatically
            </param>
            <param name="isRequire">When true, import will be generated as "import ImportTarget = require('ImportSource')"</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.AddReference(Reinforced.Typings.Fluent.ConfigurationBuilder,System.String)">
            <summary>
                Adds global reference to another typescript library
            </summary>
            <param name="conf">Table configurator</param>
            <param name="path">Full path to .d.ts or .ts file</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.AddImport(Reinforced.Typings.Fluent.ConfigurationBuilder,System.String,System.String,System.Boolean)">
            <summary>
                Adds import directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="conf">Configurator</param>
            <param name="target">
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </param>
            <param name="from">
            Import source is everything that follows after "from" keyword. 
            Please not the you do not have to specify quotes here! Quotes will be added automatically
            </param>
            <param name="isRequire">When true, import will be generated as "import ImportTarget = require('ImportSource')"</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.ExportTo``1(``0,System.String)">
            <summary>
                Overrides target file name where specified name will be exported.
                This option will only be processed when RtDivideTypesAmongFiles is true.
            </summary>
            <param name="configuration">Configurator</param>
            <param name="fileName">Target file path override. Related to RtTargetDirectory</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.OverrideName``1(``0,System.String)">
            <summary>
                Overrides name of specified member
            </summary>
            <param name="conf">Configuration</param>
            <param name="name">Custom name to be used</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.CamelCase``1(``0)">
            <summary>
                Forces member name to be camelCase
            </summary>
            <param name="conf">Configuration</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.PascalCase``1(``0)">
            <summary>
                Forces member name to be PascalCase
            </summary>
            <param name="conf">Configuration</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.DontIncludeToNamespace``1(``0,System.Boolean)">
            <summary>
                Configures exporter dont to export member to corresponding namespace
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.OverrideNamespace``1(``0,System.String)">
            <summary>
                Configures exporter to export type to specified namespace
            </summary>
            <param name="conf">Configuration</param>
            <param name="nameSpace">Namespace name</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Type``1(``0,System.String)">
            <summary>
                Overrides member type name on export with textual string.
                Beware of using this setting because specified type may not present in your TypeScript code and
                this will lead to TypeScript compilation errors
            </summary>
            <param name="conf">Configurator</param>
            <param name="typeName">TS-friendly type name</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Type``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsTypedAttributeBase})">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
            </summary>
            <param name="conf">Configurator</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Type``1(``0,System.Type)">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
            </summary>
            <param name="conf">Configurator</param>
            <param name="type">Type to override with</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Returns``1(``0,System.String)">
            <summary>
                Overrides member type name on export with textual string.
                Beware of using this setting because specified type may not present in your TypeScript code and
                this will lead to TypeScript compilation errors.
                Actually this method does the same as .Type call. Just for your convinence
            </summary>
            <param name="conf">Configurator</param>
            <param name="typeName">TS-friendly type name</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Returns``1(Reinforced.Typings.Fluent.Interfaces.IAttributed{Reinforced.Typings.Attributes.TsFunctionAttribute})">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
                Actually this method does the same as .Type call. Just for your convinence
            </summary>
            <param name="conf">Configurator</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Returns``1(``0,System.Type)">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
                Actually this method does the same as .Type call. Just for your convinence
            </summary>
            <param name="conf">Configurator</param>
            <param name="type">Type to override with</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.ForceNullable``1(``0,System.Nullable{System.Boolean})">
            <summary>
                Forces property to be a nullable.
                When set to true then property will be generated as [property]? : [type] with
                forcibly added question mark denoting nullable field.
            </summary>
            <param name="conf">Configuration</param>
            <param name="force">Force nullable or not</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.DefaultValue``1(``0,System.Object)">
            <summary>
                Sets parameter default value.
            </summary>
            <param name="conf">Configuration</param>
            <param name="value">Default value for parameter</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.AutoI``1(``0,System.Boolean)">
            <summary>
                Forces exporter to add I letter as interface prefix.
            </summary>
            <param name="conf">Configuration</param>
            <param name="auto">Add I automatically or not</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.TryLookupDocumentationForAssembly(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Reflection.Assembly,System.String)">
            <summary>
                Tries to find documentation .xml file for specified assembly and take it in account when generating documentaion
            </summary>
            <param name="conf">Table configurator</param>
            <param name="assmbly">Assembly which documentation should be included</param>
            <param name="documentationFileName">Override XMLDOC file name if differs (please include .xml extension)</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Order``1(``0,System.Double)">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conf">Configurator</param>
            <param name="order">Order of member</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Substitute(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Type,Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Defines global type substitution. Substituted type will be strictly replaced with substitution during export
            </summary>
            <param name="builder"></param>
            <param name="substitute">Type to substitute</param>
            <param name="substitution">Substitution for type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Substitute``1(``0,System.Type,Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Defines local type substitution that will work only when exporting current class. 
            Substituted type will be strictly replaced with substitution during export but this option will take effect only when 
            exporting currently configurable type
            </summary>
            <param name="builder"></param>
            <param name="substitute">Type to substitute</param>
            <param name="substitution">Substitution for type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypingsConfigurationExtensions.Implement``1(``0,System.String)">
            <summary>
            Sets function body (works in case of class export) that will be converted to RtRaw and inserted as code block
            </summary>
            <param name="builder"></param>
            <param name="functionCode">Function code</param>
            <returns></returns>
        </member>
        <member name="T:Reinforced.Typings.GeneratorManager">
            <summary>
            Class for managing and instantiating code generators
            </summary>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorFor``1(``0,Reinforced.Typings.ExportContext)">
            <summary>
                Reteieves code generator instance for specified type member.
                Also this method considers Typings attribute and instantiates generator specified there if necessary
            </summary>
            <typeparam name="T">Type member info type</typeparam>
            <param name="member">Type member info</param>
            <param name="context">Export settings</param>
            <returns>Code generator for specified type member</returns>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorFor(System.Reflection.ParameterInfo,Reinforced.Typings.ExportContext)">
            <summary>
                Retrieves code generator for ParameterInfo (since ParameterInfo does not derive from MemberInfo).
                Also this method considers Typings attribute and instantiates generator specified there if necessary
            </summary>
            <param name="member">Parameter info</param>
            <param name="context">Export settings</param>
            <returns>Code generator for parameter info</returns>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorFor(System.Type,Reinforced.Typings.ExportContext)">
            <summary>
                Retrieves code generator for specified type
                Also this method considers Typings attribute and instantiates generator specified there if necessary
            </summary>
            <param name="member">Type info</param>
            <param name="context">Export settings</param>
            <returns>Code generator for specified type</returns>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorForNamespace(Reinforced.Typings.ExportContext)">
            <summary>
                Retrieves code generator for namespaces
            </summary>
            <returns></returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1">
            <summary>
            Base code generator both for TypeScript class and interface
            </summary>
            <typeparam name="TNode">Resulting node type (RtClass or RtInterface)</typeparam>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.Export(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports entire class to specified writer
            </summary>
            <param name="result">Exporting result</param>
            <param name="type">Exporting class type</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportMembers(System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.ITypeMember,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports all type members sequentially
            </summary>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="typeMember">Placeholder for members</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.HandleBaseClassExportingAsInterface(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Here you can customize what to export when base class is class but exporting as interface
            </summary>
            <param name="sw">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportFields(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type fields
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportProperties(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type properties
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportMethods(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type methods
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportConstructors(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type constructors
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.GenerateMembers``1(System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.ITypeMember,System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Exports list of type members
            </summary>
            <typeparam name="T">Type member type</typeparam>
            <param name="element">Exporting class</param>
            <param name="resolver">Type resolver</param>
            <param name="typeMember">Output writer</param>
            <param name="members">Type members to export</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ClassCodeGenerator">
            <summary>
                Default code generator for CLR type (class)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassCodeGenerator.GenerateNode(System.Type,Reinforced.Typings.Ast.RtClass,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ConstructorCodeGenerator">
            <summary>
                Default code generator for constructor
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ConstructorCodeGenerator.GenerateNode(System.Reflection.ConstructorInfo,Reinforced.Typings.Ast.RtConstructor,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ContextExtensions">
            <summary>
                Various extensions for settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.ConditionallyConvertMethodNameToCamelCase(Reinforced.Typings.ExportContext,System.String)">
            <summary>
                Conditionally (based on settings) turns method name to camelCase
            </summary>
            <param name="context">Settings object</param>
            <param name="regularName">Regular method name</param>
            <returns>Method name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.ConditionallyConvertMethodNameToPascalCase(Reinforced.Typings.ExportContext,System.String)">
            <summary>
                Conditionally (based on settings) turns method name to PascalCase
            </summary>
            <param name="context">Settings object</param>
            <param name="regularName">Regular method name</param>
            <returns>Method name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.ConditionallyConvertPropertyNameToCamelCase(Reinforced.Typings.ExportContext,System.String)">
            <summary>
                Conditionally (based on settings) turns property name to camelCase
            </summary>
            <param name="context">Settings object</param>
            <param name="regularName">Regular property name</param>
            <returns>Property name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.CamelCaseFromAttribute(System.Reflection.MemberInfo,System.String)">
            <summary>
                Conditionally (based on attribute setting) turns member name to camelCase
            </summary>
            <param name="member">Member</param>
            <param name="regularName">Regular property name</param>
            <returns>Property name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.PascalCaseFromAttribute(System.Reflection.MemberInfo,System.String)">
            <summary>
                Conditionally (based on attribute setting) turns member name to PascalCase
            </summary>
            <param name="member">Member</param>
            <param name="regularName">Regular property name</param>
            <returns>Property name in PascalCase if pascalCasing enabled, initial string otherwise</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.EnumGenerator">
            <summary>
                Default code generator for enums
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.EnumGenerator.GenerateNode(System.Type,Reinforced.Typings.Ast.RtEnum,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.FieldCodeGenerator">
            <summary>
                Default code generator for fields
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.FieldCodeGenerator.GetType(System.Reflection.MemberInfo)">
            <summary>
                That's it - overriden GetType for property since properties and fields are exported to TypeScript almost same way.
            </summary>
            <param name="mi">Member info (Fields behind)</param>
            <returns>Field type</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.InterfaceCodeGenerator">
            <summary>
                Default code generator for interfaces. Derived from class generator since interfaces are very similar to classes in
                TypeScript
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.InterfaceCodeGenerator.GenerateNode(System.Type,Reinforced.Typings.Ast.RtInterface,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ITsCodeGenerator`1">
            <summary>
                TypeScript code generator interface
            </summary>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="P:Reinforced.Typings.Generators.ITsCodeGenerator`1.Context">
            <summary>
                Export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ITsCodeGenerator`1.Generate(`0,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should return corresponding AST node for provided 
                reflection element using source Reflection element and RT's Type Resolver
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.MethodCodeGenerator">
            <summary>
                Default typescript code generator for method
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.MethodCodeGenerator.GenerateNode(System.Reflection.MethodInfo,Reinforced.Typings.Ast.RtFuncion,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.MethodCodeGenerator.GetFunctionNameAndReturnType(System.Reflection.MethodInfo,Reinforced.Typings.TypeResolver,System.String@,Reinforced.Typings.Ast.TypeNames.RtTypeName@)">
            <summary>
                Retrieves function name corresponding to method and return type. Fell free to override it.
            </summary>
            <param name="element">Method info</param>
            <param name="resolver">Type resolver</param>
            <param name="name">Resulting method name</param>
            <param name="type">Resulting return type name</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.NamespaceCodeGenerator">
            <summary>
                Default code generator for namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Generators.NamespaceCodeGenerator.Context">
            <summary>
                Export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.NamespaceCodeGenerator.Generate(System.Collections.Generic.IEnumerable{System.Type},System.String,Reinforced.Typings.TypeResolver)">
            <summary>
                Generates namespace source code
            </summary>
            <param name="types">Types list</param>
            <param name="namespaceName">Namespace name</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ParameterCodeGenerator">
            <summary>
                Default code generator for method parameter
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ParameterCodeGenerator.GenerateNode(System.Reflection.ParameterInfo,Reinforced.Typings.Ast.RtArgument,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ParameterCodeGenerator.GetDefaultValue(System.Reflection.ParameterInfo,Reinforced.Typings.Attributes.TsParameterAttribute)">
            <summary>
                Returns default value for specified parameter info
            </summary>
            <param name="element">Parameter info</param>
            <param name="attr">Parameter attribute</param>
            <returns>Serialized to string default value of type that is exposed by mentioned parameter</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.PropertyCodeGenerator">
            <summary>
                Default code generator for properties
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.PropertyCodeGenerator.GenerateNode(System.Reflection.MemberInfo,Reinforced.Typings.Ast.RtField,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.PropertyCodeGenerator.GetType(System.Reflection.MemberInfo)">
            <summary>
                Returns type of specified property. It is useful for overloads sometimes
            </summary>
            <param name="mi">Method Info</param>
            <returns>Property info type</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.TsCodeGeneratorBase`2">
            <summary>
            Base for strongly-typed code generator with automatical Context.Location handling
            </summary>
            <typeparam name="T">Source reflection [Something]Info type. Possible: Type, MethodInfo, PropertyInfo, ConstructorInfo, FieldInfo</typeparam>
            <typeparam name="TNode">Resulting node type</typeparam>
        </member>
        <member name="P:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.Context">
            <summary>
             Export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.Generate(`0,Reinforced.Typings.TypeResolver)">
            <summary>
            Generate method implementation. 
            Calls GenerateNode inside, creates node dummy, sets and resets location
            </summary>
            <param name="element">Reflection element instance</param>
            <param name="resolver">Type resolver</param>
            <returns>Generated node or null</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.GenerateNode(`0,`1,Reinforced.Typings.TypeResolver)">
            <summary>
            Main entry point for resulting node generation.  
            </summary>
            <param name="element">Reflection element</param>
            <param name="node">Resulting node to be modified</param>
            <param name="resolver">Type resolver</param>
            <returns>Resulting node or null</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.AddDecorators(Reinforced.Typings.Ast.IDecoratable,System.Collections.Generic.IEnumerable{Reinforced.Typings.Attributes.TsDecoratorAttribute})">
            <summary>
            Appends decorators to decoratable node
            </summary>
            <param name="node">Decoratable syntax node</param>
            <param name="decorators">Set of decorator attributes</param>
        </member>
        <member name="T:Reinforced.Typings.GlobalParameters">
            <summary>
            Collections of global TS generation parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.WriteWarningComment">
            <summary>
                Boolean parameter that controls writing of "auto-generated warning" comment to each generated file.
            It meant the comment like "// This code was generated blah blah blah..."
            'true' (default) to write warning comment about auto-generated to every file.
            'false' to do not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.RootNamespace">
            <summary>
                Specifies root namespace for hierarchical export.
                Helps to avoid creating redundant directories when hierarchical export.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.CamelCaseForMethods">
            <summary>
                Use camelCase for methods naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.CamelCaseForProperties">
            <summary>
                Use camelCase for properties naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.GenerateDocumentation">
            <summary>
                Enables or disables documentation generator
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.TabSymbol">
            <summary>
            Specifies symbol used for tabulation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.UseModules">
            <summary>
            Switches RT to using TS modules system (--module) parameter and import references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.DiscardNamespacesWhenUsingModules">
            <summary>
            When true, RT will ignore classes' namespaces when arraging classes and interfaces among files. 
            This parameter only makes difference when using (--module)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.ExportPureTypings">
            <summary>
                If true, export will be performed in .d.ts manner (only typings, declare module etc).
                Otherwise, export will be performed to regulat .ts file
            </summary>
        </member>
        <member name="T:Reinforced.Typings.IFilesOperations">
            <summary>
            Interface of files operator
            It has to be public for testing purposes
            </summary>
        </member>
        <member name="P:Reinforced.Typings.IFilesOperations.Context">
            <summary>
            Export context
            </summary>
        </member>
        <member name="M:Reinforced.Typings.IFilesOperations.DeployTempFiles">
            <summary>
            Writes temporary files contents to disk
            </summary>
        </member>
        <member name="M:Reinforced.Typings.IFilesOperations.ClearTempRegistry">
            <summary>
            Cleans up temporary files registry
            </summary>
        </member>
        <member name="M:Reinforced.Typings.IFilesOperations.Export(System.String,Reinforced.Typings.ExportedFile)">
            <summary>
            Exports specified syntax nodes to specified file
            </summary>
            <param name="fileName">File name</param>
            <param name="file">File to be exported</param>
        </member>
        <member name="T:Reinforced.Typings.InlineTypeInferers`1">
            <summary>
            Class holding inline type inferers for specified node
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Reinforced.Typings.InferringOverrideExtensions">
            <summary>
            Extensions for inline type inferer
            </summary>
        </member>
        <member name="M:Reinforced.Typings.InferringOverrideExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,Reinforced.Typings.TypeResolver,System.String})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.InferringOverrideExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.InferringOverrideExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,System.String})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.InferringOverrideExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.ISupportsInferring`1">
            <summary>
            Decorates member that supports inline type inferring
            </summary>
            <typeparam name="T">Member Type</typeparam>
        </member>
        <member name="P:Reinforced.Typings.ISupportsInferring`1.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Location">
            <summary>
            Identifies where current export is performed in terms of AST. 
            Context.Location could be used to conditionally add members to different places of generated source code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentClass">
            <summary>
            Current Class 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentInterface">
            <summary>
            Current Interface
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentEnum">
            <summary>
            Current Enum
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentNamespace">
            <summary>
            Current Module
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentType">
            <summary>
            References currently exported type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Location.SetLocation(Reinforced.Typings.Ast.RtNode)">
            <summary>
            Sets current location
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:Reinforced.Typings.Location.ResetLocation(Reinforced.Typings.Ast.RtNode)">
            <summary>
            Sets current location
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:Reinforced.Typings.Location.SetCurrentType(System.Type)">
            <summary>
            Sets currently exported type
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Reinforced.Typings.Location.ResetCurrentType">
            <summary>
            Resets currently exported type
            </summary>
        </member>
        <member name="T:Reinforced.Typings.ReferencesInspection.InspectedReferences">
            <summary>
            Represents inspected references for type or global references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ReferencesInspection.InspectedReferences.References">
            <summary>
            References exposed via &lt;reference path="..."&gt; tag
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ReferencesInspection.InspectedReferences.Imports">
            <summary>
            References exposed via imports
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ReferencesInspection.InspectedReferences.StarImports">
            <summary>
            Cache of starred imports. Key is "from", value is star import alias
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.#ctor(System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.Dependency.RtReference},System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.Dependency.RtImport})">
            <summary>
            Constructs new inspected references set
            </summary>
            <param name="references">References</param>
            <param name="imports">Imports</param>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.Duplicate">
            <summary>
            Duplicates inspected references for further usage
            </summary>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.AddReference(Reinforced.Typings.Ast.Dependency.RtReference)">
            <summary>
            Attaches new reference to existing ones
            </summary>
            <param name="reference">New reference</param>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.AddImport(Reinforced.Typings.Ast.Dependency.RtImport)">
            <summary>
            Attaches new import to existing ones
            </summary>
            <param name="import">Import</param>
        </member>
        <member name="T:Reinforced.Typings.ReferencesInspection.ReferenceInspector">
            <summary>
            Class responsible for extracting direct dependencies from types
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.ReferenceInspector.InspectGlobalReferences">
            <summary>
            Inspects global assemblies defined with assembly attributes or fluent methods
            </summary>
            <returns>Set of inspected references</returns>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.ReferenceInspector.EnsureImport(System.Type,System.String,Reinforced.Typings.ExportedFile)">
            <summary>
            Ensures that imports for specified type presents in specified file
            </summary>
            <param name="t">Type to import</param>
            <param name="typeName">Type name (probably overriden)</param>
            <param name="file">Exported file</param>
            <returns>Import AST node or null if no import needed. Returns existing import in case if type is already imported</returns>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.ReferenceInspector.EnsureReference(System.Type,Reinforced.Typings.ExportedFile)">
            <summary>
            Ensures that reference for specified type presents in specified file
            </summary>
            <param name="t">Type to reference</param>
            <param name="file">Exported file</param>
            <returns>Reference AST node or null if no reference needed. Returns existing reference in case if type is already referenced</returns>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.ReferenceInspector.GetPathForType(System.Type,System.Boolean)">
            <summary>
            Retrieves full path to file where specified type will be exported to
            </summary>
            <param name="t">Type</param>
            <param name="stripExtension">Remove file extension. Set to false if you still want to get path with extension in case of module export</param>
            <returns>Full path to file containing exporting type</returns>
        </member>
        <member name="T:Reinforced.Typings.TsExporter">
            <summary>
                Facade for final TypeScript export. This class supplies assemblies names or assemblies itself as parameter and
                exports resulting TypeScript file to file or to string
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TsExporter.GlobalReferences">
            <summary>
            Global references extracted from current configuration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TsExporter.ReferenceInspector">
            <summary>
            Reference inspector instance
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.#ctor(Reinforced.Typings.ExportContext)">
            <summary>
                Constructs new instance of TypeScript exporter
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.Initialize">
            <summary>
            Initializes TS exporter. Reads all types configuration, applies fluent configuration, resolves references
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.SetupExportedFile(System.String)">
            <summary>
            Sets up exported file dummy
            </summary>
            <param name="fileName">File name</param>
            <returns>Exported file dummy</returns>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.ExportTypes(System.String)">
            <summary>
                Exports TypeScript source to specified TextWriter according to settings
            </summary>
            <param name="fileName">File name to export files to</param>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.Export">
            <summary>
                Exports TypeScript source according to settings
            </summary>
        </member>
        <member name="T:Reinforced.Typings.TypeExtensions">
            <summary>
                Useful extensions for reflection
            </summary>
        </member>
        <member name="F:Reinforced.Typings.TypeExtensions.MembersFlags">
            <summary>
                Binding flags for searching all members
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsStatic(System.Type)">
            <summary>
                Determines is type is static
            </summary>
            <param name="t">Type</param>
            <returns>True if type is static. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsStatic(System.Reflection.MemberInfo)">
            <summary>
                Determines is member static or not
            </summary>
            <param name="member">Type member</param>
            <returns>True if member is static. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsStatic(System.Reflection.PropertyInfo)">
            <summary>
                Determines is property static or not
            </summary>
            <param name="propertyInfo">Property</param>
            <returns>True if member is static. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsNullable(System.Type)">
            <summary>
                Determines is type derived from Nullable or not
            </summary>
            <param name="t">Type</param>
            <returns>True if type is nullable value type. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsTuple(System.Type)">
            <summary>
            Determines if type is one of System.Tuple types set
            </summary>
            <param name="t">Type to check</param>
            <returns>True when type is tuple, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsDictionary(System.Type)">
            <summary>
                Determines if type is Dictionary-like
            </summary>
            <param name="t">Type</param>
            <returns>True if type is derived from dictionary type</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsEnumerable(System.Type)">
            <summary>
                Determines if type is enumerable regardless of generic spec
            </summary>
            <param name="t">Type</param>
            <returns>True if type is enumerable (incl. array type). False otherwise.</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsNongenericEnumerable(System.Type)">
            <summary>
                Determines if supplied type is non-generic enumerable
            </summary>
            <param name="t">Type</param>
            <returns>True if supplied type is nongeneric enumerable. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsDelegate(System.Type)">
            <summary>
                Determines if supplied type is delegate type
            </summary>
            <param name="t">Type</param>
            <returns>True, if supplied type is delegate, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.FieldInfo)">
            <summary>
                Returns access modifier for specified field
            </summary>
            <param name="fieldInfo">Field</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.MethodInfo)">
            <summary>
                Returns access modifier for specified method
            </summary>
            <param name="methodInfo">Method</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.ConstructorInfo)">
            <summary>
                Returns access modifier for specified constructor
            </summary>
            <param name="constructorInfo">Constructor</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.PropertyInfo)">
            <summary>
                Returns access modifier for specified constructor
            </summary>
            <param name="propertyInfo">Property</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.MemberInfo)">
            <summary>
                Returns access modifier for specified type member
            </summary>
            <param name="member">Type member</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.ToModifierText(Reinforced.Typings.AccessModifier)">
            <summary>
                Converts AccessModifier to corresponding TypeScript source text
            </summary>
            <param name="modifier">Access modifier</param>
            <returns>Access modifier text</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.ToModifierOmitPublic(Reinforced.Typings.AccessModifier)">
            <summary>
                Converts AccessModifier to corresponding TypeScript source text
            </summary>
            <param name="modifier">Access modifier</param>
            <returns>Access modifier text</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetArg(System.Type)">
            <summary>
                Retrieves first type argument of type
            </summary>
            <param name="t">Type</param>
            <returns>First type argument</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.CleanGenericName(System.Type)">
            <summary>
                Removes generics postfix (all text after '`') from typename
            </summary>
            <param name="t">Type</param>
            <returns>Clean, genericless name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsBounceProperty(System.Reflection.PropertyInfo)">
            <summary>
                Determines if propercy is "bounced".
                It means property with different accesor's access level
            </summary>
            <param name="propertyInfo">Property</param>
            <returns>True if property has different access levels for accessor</returns>
        </member>
        <member name="T:Reinforced.Typings.TypeResolver">
            <summary>
                Type resolver. It is helper class to convert source types, members and parameter names to typescript ones
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeResolver.#ctor(Reinforced.Typings.ExportContext,Reinforced.Typings.ExportedFile,Reinforced.Typings.ReferencesInspection.ReferenceInspector)">
            <summary>
                Constructs new type resolver
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeResolver.ResolveTypeName(System.Type)">
            <summary>
                Returns typescript-friendly type name node for specified type.
                This method successfully handles dictionaries, IEnumerables, arrays, another TsExport-ed types, void, delegates,
                most of CLR built-in types, parametrized types etc.
                It also considers Ts*-attributes while resolving type names
                If it cannot handle anything then it will return "any"
            </summary>
            <param name="t">Specified type</param>
            <returns>Typescript-friendly type name</returns>
        </member>
        <member name="T:Reinforced.Typings.Xmldoc.DocumentationManager">
            <summary>
                XMLDOC documentation manager
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Reflection.MemberInfo)">
            <summary>
                Returns documentation member for class member
            </summary>
            <param name="member">Class member</param>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Reflection.MethodInfo)">
            <summary>
            Returns documentation member for method
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Reflection.ConstructorInfo)">
            <summary>
                Returns documentation for constructor
            </summary>
            <param name="constructor">Constructor</param>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Type)">
            <summary>
                Returns documentation for type
            </summary>
            <param name="type">Type</param>
        </member>
    </members>
</doc>
